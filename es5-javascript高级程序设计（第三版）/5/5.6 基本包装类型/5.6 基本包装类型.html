<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>5.6 基本包装类型</title>
</head>
<body>

<script>
    // 为了便于操作基本类型值，ECMAScript
    // 提供了3 个特殊的引用类型：Boolean、Number 和String。


    //     这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。
    //    每当‘读取’一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们
    //     能够调用一些方法来操作这些数据。

    var s1 = 'some text';
    var s2 = s1.substring(2);//基本类型值不是对象，因而从逻辑上讲它们不应该有方法

    //     其实，为了让我们实现这种直观的操作，
    // 后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要
    //     从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。
    //
    // (1) 创建 String 类型的一个实例；
    // (2) 在实例上调用指定的方法；
    // (3) 销毁这个实例。

    var s1 = new String("some text");
    var s2 = s1.substring(2);
    s1 = null;


    //     引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，
    // 在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一
    //     行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。

    var s1 = "some text";
    s1.color = "red";//创建的String对象 在执行第三行代码时已经被销毁
    console.log(s1.color); //undefined  读取模式 时再次创建对象  而此对象没有color 属性


    // 当然，可以显式地调用 Boolean、Number 和 String 来创建基本包装类型的对象。不过，应该在
    // 绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的
    // 值。对基本包装类型的实例调用 typeof 会返回"object"，


    //     Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：
    var obj = new Object("some text");//
    console.log(obj instanceof String); //true

    // 把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到 Number 的实
    // 例，传入布尔值参数就会得到 Boolean 的实例。


    //     要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。
    // 例如:

    var value = "25";
    var number = Number(value); //转型函数
    console.log(typeof number); //"number"
    var obj = new Number(value); //构造函数
    console.log(typeof obj); //"object"
    // 在这个例子中，变量 number 中保存的是基本类型的值 25，而变量 obj 中保存的是 Number 的实
    // 例。要了解有关转型函数的更多信息，请参考第 3 章。

//     尽管不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。
// 而每个基本包装类型都提供了操作相应值的便捷方法。
</script>
</body>
</html>
